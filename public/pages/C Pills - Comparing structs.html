<!DOCTYPE html>
<html lang="en-gb">
<head>
  <title>C Pills - Comparing structs - NicknEma</title>
  
  <!-- Metadata -->
  <meta charset="utf-8" />
  <meta name="author" content="Emanuele Rovini">
  <meta name="description" content="Things you need to be aware of when comparing structs">
  <meta name="keywords" content="C struct memcmp padding alignment">
  <meta
    name="theme-color"
    content="lightgray"
    media="(prefers-color-scheme: light)" />
  <meta
    name="theme-color"
    content="darkgray"
    media="(prefers-color-scheme: dark)" />
  <meta name="color-scheme" content="dark light" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <script>
    MathJax = {
      tex: {
        displayMath: [['\\[', '\\]'], ['$$', '$$']],  
        inlineMath: [['\\(', '\\)']]                  
      }
    };
  </script>

  <link href="/styles/normal.css" rel="stylesheet">
</head>

<body>
 <nav>
    <h1>
      <a id="home_button" href="/" style="cursor: pointer">
        NicknEma
      </a>
    </h1>
  </nav>
  
  <header>
    <h1><strong>C Pills - Comparing structs</strong></h1>
    <p class="details">Things you need to be aware of when comparing structs.<br />
    Last modified <time datetime="2026-01-24">24/01/2026</time></p>
  </header>
  <main>
    <article>
      <p>The C programming language does not define the equality operator <code>==</code> for compound types (structs).
      If you want to compare two variables of the same compound type, you have to explicitly compare each field:</p>

      <pre><code><span style="color:var(--code-keyword-color)">struct</span> my_vec { <span style="color:var(--code-keyword-color)">int</span> x, y; };
<span style="color:var(--code-keyword-color)">struct</span> my_vec v1 = {0}, <span style="color:var(--code-keyword-color)">struct</span> my_vec v2 = {0};

<span style="color:var(--code-keyword-color)">if</span> (v1 == v2);                     <span style="color:var(--code-comment-color)">// Not allowed</span>
<span style="color:var(--code-keyword-color)">if</span> (v1.x == v2.x && v1.y == v2.y); <span style="color:var(--code-comment-color)">// You have to do this</span></code></pre>

      <p>This is error-prone, annoying to type and verbose, so it is tempting to just call <code><a href="https://man7.org/linux/man-pages/man3/memcmp.3.html">memcmp</a></code>. That's what it was made for, right?</p>
      <p>Yes. And no.
      When the compiler generates code for a struct, it doesn't only make sure that it is large enough for all members to fit;
      it also has to place each field at its correct alignment.</p>
      <p>Suppose you have a struct that looks like this:</p>

      <pre><code><span style="color:var(--code-keyword-color)">struct</span> my_type {
    int32_t x;
    int64_t y;
};</code></pre>

      <p>If we just look at the size of individual fields, it looks like the total size should be 4+8=12 bytes.<br />
      What we don't see is that the compiler wants to place 8-byte fields as <i>8-byte aligned</i> (that is, it wants the bottom log_2(8)=3 bits of the offset to be zeros).
      Assuming that the struct starts at address <code>0x0</code>, the first offset after that to have 3 zero bits at the bottom is <code>0x8</code>, exactly 4 bytes after the end of the <code>length</code> field.
      This will leave an empty, unnamed 4-byte gap between <code>x</code> and <code>y</code>.</p>

      <div style="display: flex; display-direction: row">
      <figure style="margin: 0 auto;">
        <svg width="280" height="240" viewBox="0 0 280 240">
          <rect x="40" y="40" width="40" height="120" fill="none" stroke="darkgray" stroke-width="3" />
          <line x1="40" y1="80" x2="80" y2="80" stroke="darkgray" stroke-width="3"/>
          
          <text x="90" y="60" style="font-family:monospace; fill:darkgray">x</text>
          <text x="90" y="100" style="font-family:monospace; fill:darkgray">y</text>
        </svg>
        <figcaption>The struct with no padding</figcaption>
      </figure>
      <figure style="margin: 0 auto">
        <svg width="280" height="240" viewBox="0 0 280 240">
          <rect x="40" y="40" width="40" height="160" fill="none" stroke="darkgray" stroke-width="3" />
          <line x1="40" y1="80" x2="80" y2="80" stroke="darkgray" stroke-width="3"/>
          <line x1="40" y1="120" x2="80" y2="120" stroke="darkgray" stroke-width="3"/>
          
          <text x="90" y="60" style="font-family:monospace; fill:darkgray">x</text>
          <text x="90" y="100" style="font-family:monospace; fill:darkgray">padding</text>
          <text x="90" y="140" style="font-family:monospace; fill:darkgray">y</text>
        </svg>
        <figcaption>How it really is</figcaption>
      </figure>
      </div>

      <p>What does this gap contain? It could be anything. The programmer can't read from or write to it, unless they use pointer arithmetic. Compilers aren't required to initialize this space with anything. Yes, even if you explicityly do zero-initialization of the variable like this:</p>

      <pre><code><span style="color:var(--code-comment-color)">// Compiler still allowed to do whatever it wants with those padding bytes</span>
<span>style="color:var(--code-keyword-color)">struct</span> my_type a = {0};</code></pre>

      <p>This is generally not a problem, but it becomes one if two variables of this compound type are compared with <code>memcmp</code>:
      even if both fields of the variables are identical, <code>memcmp</code> could still return non-zero if it finds those padding bytes to be different.</p>

      <div style="display: flex; display-direction: row">
      <figure style="margin: 0 auto;">
        <svg width="240" height="200" viewBox="0 0 240 200">
          <rect x="40" y="40" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />
          <rect x="80" y="40" width="40" height="40" fill="#fcc" stroke="darkgray" stroke-width="3" />
          <rect x="120" y="40" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />
          <rect x="160" y="40" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />

          <rect x="40" y="120" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />
          <rect x="80" y="120" width="40" height="40" fill="#fcc" stroke="darkgray" stroke-width="3" />
          <rect x="120" y="120" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />
          <rect x="160" y="120" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />

          <text x="45" y="60" style="font-family:monospace; fill:darkgray">0xDE</text>
          <text x="85" y="60" style="font-family:monospace; fill:darkgray">0x2A</text>
          <text x="125" y="60" style="font-family:monospace; fill:darkgray">0xBE</text>
          <text x="165" y="60" style="font-family:monospace; fill:darkgray">0xEF</text>
          
          <text x="45" y="140" style="font-family:monospace; fill:darkgray">0xDE</text>
          <text x="85" y="140" style="font-family:monospace; fill:darkgray">0x45</text>
          <text x="125" y="140" style="font-family:monospace; fill:darkgray">0xBE</text>
          <text x="165" y="140" style="font-family:monospace; fill:darkgray">0xEF</text>
          
          </svg>
        <figcaption>Comparing with memcmp</figcaption>
      </figure>
      </div>

      <p>This could be the intended behaviour, but it usually isn't.</p>
      <p>This leaves the programmer with two options, neither of which is optimal.
      The first is to compare each field individually, and wrap that into a function when it starts to get repeptitive.
      The second is to make sure that <em>no implicit padding bytes are inserted in the struct</em> by making them explicit:</p>

      <pre><code><span style="color:var(--code-keyword-color)">struct</span> my_type {
    int32_t x;
    int32_t _pad0[0]; <span style="color:var(--code-comment-color)">// Exactly fits the gap left between length and data</span>
    int64_t y;
};

<span style="color:var(--code-keyword-color)">struct</span> my_type s = {0}; <span style="color:var(--code-comment-color)">// Now the compiler is required to cooperate</span></code></pre>
      <p>Of course this could be tiresome if working with data types subject to frequent changes.</p>
    </article>
  </main>

  <footer>
    <div>
      Emanuele Rovini, <time>2026</time> &ndash; Powered by <strong>plain HTML</strong>
    </div>
  </footer>
</body>
</html>