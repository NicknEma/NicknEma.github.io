<!DOCTYPE html>
<html lang="en-gb">
<head>
  <title>C Pills - Comparing structs - NicknEma</title>
  
  <!-- Metadata -->
  <meta charset="utf-8" />
  <meta name="author" content="Emanuele Rovini">
  <meta name="description" content="Things you need to be aware of when comparing structs">
  <meta name="keywords" content="C struct memcmp padding alignment">
  <meta
    name="theme-color"
    content="lightgray"
    media="(prefers-color-scheme: light)" />
  <meta
    name="theme-color"
    content="darkgray"
    media="(prefers-color-scheme: dark)" />
  <meta name="color-scheme" content="dark light" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  <script>
    MathJax = {
      tex: {
        displayMath: [['\\[', '\\]'], ['$$', '$$']],  
        inlineMath: [['\\(', '\\)']]                  
      }
    };
  </script>

  <link href="/styles/normal.css" rel="stylesheet">
</head>

<body>
 <nav>
    <h1>
      <a id="home_button" href="/" style="cursor: pointer">
        NicknEma
      </a>
    </h1>
  </nav>
  
  <header>
    <h1><strong>C Pills - Comparing structs</strong></h1>
    <p class="details">Things you need to be aware of when comparing structs.<br />
    Last modified <time datetime="2026-01-24">24/01/2026</time></p>
  </header>
  <main>
    <article>

<p>The C programming language does not define the equality operator <code>==</code> for compound types (structs).
If you want to compare two variables of the same compound type, you have to explicitly compare each field:</p>

<div class="code-block">
<div class="code-block-bar">
<span>C</span>
<button type="button" class="code-block-copy-button" onclick="let c = `struct my_vec { int x, y; };
struct my_vec v1 = {0}, struct my_vec v2 = {0};

if (v1 == v2);                     // Not allowed
if (v1.x == v2.x && v1.y == v2.y); // You have to do this`; navigator.clipboard.writeText(c)">Copy</button>
</div>
<div class="code-block-content" data-code-block itemscope itemtype="https://schema.org/SoftwareSourceCode">
<meta itemprop="codeSampleType" content="snippet" />
<meta itemprop="programmingLanguage" content="C" />
<!-- <meta data-code-id="evalOrder" itemprop="text" content="" /> -->
<pre tabindex="0"><code class="language-C" data-lang="C"><span class="line"><span><span class="token keyword">struct</span> <span class="token typename">my_vec</span> { <span class="token keyword">int</span> x, y; };
</span></span><span class="line"><span><span class="token keyword">struct</span> <span class="token typename">my_vec</span> v1 = {<span class="token number">0</span>}, <span class="token keyword">struct</span> <span class="token typename">my_vec</span> v2 = {<span class="token number">0</span>};
</span></span><span class="line"><span>
</span></span><span class="line"><span><span class="token keyword">if</span> (v1 == v2);                     <span class="token comment">// Not allowed</span>
</span></span><span class="line"><span><span class="token keyword">if</span> (v1.x == v2.x && v1.y == v2.y); <span class="token comment">// You have to do this</span></span></span></code></pre>
</div>
</div>

<p>This is error-prone, annoying to type and verbose, so it is tempting to just call <code><a href="https://man7.org/linux/man-pages/man3/memcmp.3.html">memcmp</a></code>. That's what it was made for, right?</p>
<p>Yes. And no.
When the compiler generates code for a struct, it doesn't only make sure that it is large enough for all members to fit;
it also has to place each field at its correct alignment.</p>
<p>Suppose you have a struct that looks like this:</p>

<div class="code-block">
<div class="code-block-bar">
<span>C</span>
<button type="button" class="code-block-copy-button" onclick="let c = `struct my_type {
	int32_t x;
	int64_t y;
};`; navigator.clipboard.writeText(c)">Copy</button>
</div>
<div class="code-block-content" data-code-block itemscope itemtype="https://schema.org/SoftwareSourceCode">
<meta itemprop="codeSampleType" content="snippet" />
<meta itemprop="programmingLanguage" content="C" />
<!-- <meta data-code-id="evalOrder" itemprop="text" content="" /> -->
<pre tabindex="0"><code class="language-C" data-lang="C"><span class="line"><span><span class="token keyword">struct</span> <span class="token typename">my_type</span> {
</span></span><span class="line"><span>	<span class="token typename">int32_t</span> x;
</span></span><span class="line"><span>	<span class="token typename">int64_t</span> y;
</span></span><span class="line"><span>};</span></span></code></pre>
</div>
</div>

<p>If we just look at the size of individual fields, it looks like the total size should be 4+8=12 bytes.<br />
What we don't see is that the compiler wants to place 8-byte fields as <i>8-byte aligned</i> (that is, it wants the bottom log_2(8)=3 bits of the offset to be zeros).
Assuming that the struct starts at address <code>0x0</code>, the first offset after that to have 3 zero bits at the bottom is <code>0x8</code>, exactly 4 bytes after the end of the <code>length</code> field.
This will leave an empty, unnamed 4-byte gap between <code>x</code> and <code>y</code>.</p>

<div style="display: flex; display-direction: row">
<figure style="margin: 0 auto;">
<svg width="280" height="240" viewBox="0 0 280 240">
<rect x="40" y="40" width="40" height="120" fill="none" stroke="darkgray" stroke-width="3" />
<line x1="40" y1="80" x2="80" y2="80" stroke="darkgray" stroke-width="3"/>

<text x="90" y="60" style="font-family:monospace; fill:darkgray">x</text>
<text x="90" y="100" style="font-family:monospace; fill:darkgray">y</text>
</svg>
<figcaption>The struct with no padding</figcaption>
</figure>
<figure style="margin: 0 auto">
<svg width="280" height="240" viewBox="0 0 280 240">
<rect x="40" y="40" width="40" height="160" fill="none" stroke="darkgray" stroke-width="3" />
<line x1="40" y1="80" x2="80" y2="80" stroke="darkgray" stroke-width="3"/>
<line x1="40" y1="120" x2="80" y2="120" stroke="darkgray" stroke-width="3"/>

<text x="90" y="60" style="font-family:monospace; fill:darkgray">x</text>
<text x="90" y="100" style="font-family:monospace; fill:darkgray">padding</text>
<text x="90" y="140" style="font-family:monospace; fill:darkgray">y</text>
</svg>
<figcaption>How it really is</figcaption>
</figure>
</div>

<p>What does this gap contain? It could be anything. The programmer can't read from or write to it, unless they use pointer arithmetic. Compilers aren't required to initialize this space with anything. Yes, even if you explicityly do zero-initialization of the variable like this:</p>

<div class="code-block">
<div class="code-block-bar">
<span>C</span>
<button type="button" class="code-block-copy-button" onclick="let c = `// Compiler still allowed to do whatever it wants with those padding bytes
struct my_type a = {0};`; navigator.clipboard.writeText(c)">Copy</button>
</div>
<div class="code-block-content" data-code-block itemscope itemtype="https://schema.org/SoftwareSourceCode">
<meta itemprop="codeSampleType" content="snippet" />
<meta itemprop="programmingLanguage" content="C" />
<!-- <meta data-code-id="evalOrder" itemprop="text" content="" /> -->
<pre tabindex="0"><code class="language-C" data-lang="C"><span class="line"><span><span class="token comment">// Compiler still allowed to do whatever it wants with those padding bytes</span>
</span></span><span class="line"><span><span class="token keyword">struct</span> <span class="token typename">my_type</span> a = {<span class="token number">0</span>};</span></span></code></pre>
</div>
</div>

<p>This is generally not a problem, but it becomes one if two variables of this compound type are compared with <code>memcmp</code>:
even if both fields of the variables are identical, <code>memcmp</code> could still return non-zero if it finds those padding bytes to be different.</p>

<div style="display: flex; display-direction: row">
<figure style="margin: 0 auto;">
<svg width="240" height="200" viewBox="0 0 240 200">
<rect x="40" y="40" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />
<rect x="80" y="40" width="40" height="40" fill="#fcc" stroke="darkgray" stroke-width="3" />
<rect x="120" y="40" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />
<rect x="160" y="40" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />

<rect x="40" y="120" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />
<rect x="80" y="120" width="40" height="40" fill="#fcc" stroke="darkgray" stroke-width="3" />
<rect x="120" y="120" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />
<rect x="160" y="120" width="40" height="40" fill="#cfc" stroke="darkgray" stroke-width="3" />

<text x="45" y="60" style="font-family:monospace; fill:darkgray">0xDE</text>
<text x="85" y="60" style="font-family:monospace; fill:darkgray">0x2A</text>
<text x="125" y="60" style="font-family:monospace; fill:darkgray">0xBE</text>
<text x="165" y="60" style="font-family:monospace; fill:darkgray">0xEF</text>

<text x="45" y="140" style="font-family:monospace; fill:darkgray">0xDE</text>
<text x="85" y="140" style="font-family:monospace; fill:darkgray">0x45</text>
<text x="125" y="140" style="font-family:monospace; fill:darkgray">0xBE</text>
<text x="165" y="140" style="font-family:monospace; fill:darkgray">0xEF</text>

</svg>
<figcaption>Comparing with memcmp</figcaption>
</figure>
</div>

<p>This could be the intended behaviour, but it usually isn't.</p>
<p>This leaves the programmer with two options, neither of which is optimal.
The first is to compare each field individually, and wrap that into a function when it starts to get repeptitive.
The second is to make sure that <em>no implicit padding bytes are inserted in the struct</em> by making them explicit:</p>

<div class="code-block">
<div class="code-block-bar">
<span>C</span>
<button type="button" class="code-block-copy-button" onclick="let c = `struct my_type {
	int32_t x;
	int32_t _pad0[0]; // Exactly fits the gap left between length and data
	int64_t y;
};

struct my_type s = {0}; // Now the compiler is required to cooperate`; navigator.clipboard.writeText(c)">Copy</button>
</div>
<div class="code-block-content">
<meta itemprop="codeSampleType" content="snippet" />
<meta itemprop="programmingLanguage" content="C" />
<!-- <meta data-code-id="evalOrder" itemprop="text" content="" /> -->
<pre tabindex="0"><code class="language-C" data-lang="C"><span class="line"><span><span class="token keyword">struct</span> <span class="token typename">my_type</span> {
</span></span><span class="line"><span>	<span class="token typename">int32_t</span> x;
</span></span><span class="line"><span>	<span class="token typename">int32_t</span> _pad0[<span class="token number">0</span>]; <span class="token comment">// Exactly fits the gap left between length and data</span>
</span></span><span class="line"><span>	<span class="token typename">int64_t</span> y;
</span></span><span class="line"><span>};
</span></span><span class="line"><span>
</span></span><span class="line"><span><span class="token keyword">struct</span> <span class="token typename">my_type</span> s = {<span class="token number">0</span>}; <span class="token comment">// Now the compiler is required to cooperate</span></span></span></code></pre>
</div>
</div>

<p>Of course this could be tiresome if working with data types subject to frequent changes.</p>

    </article>
  </main>

  <footer>
    <div>
      Emanuele Rovini, <time>2026</time> &ndash; Powered by <strong>plain HTML</strong>
    </div>
  </footer>
</body>
</html>